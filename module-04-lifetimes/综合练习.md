# 综合练习：Markdown 解析器

## 项目描述

创建一个简单的 Markdown 解析器，演示生命周期和高级类型的综合应用。

## 项目结构

```
综合练习/
├── src/
│   ├── lib.rs           # 主库文件
│   ├── parser.rs        # 解析器
│   ├── ast.rs           # 抽象语法树
│   ├── renderer.rs      # 渲染器
│   └── types.rs         # 类型定义
└── tests/
    └── integration.rs   # 集成测试
```

## 核心需求

### 1. 抽象语法树

```rust
pub enum AstNode<'a> {
    Heading { level: u8, text: &'a str },
    Paragraph(Vec<&'a str>),
    CodeBlock { language: Option<&'a str>, code: &'a str },
    List { ordered: bool, items: Vec<&'a str> },
    Link { text: &'a str, url: &'a str },
    Image { alt: &'a str, url: &'a str },
    Text(&'a str),
}
```

### 2. 解析器结构

```rust
pub struct Parser<'a> {
    input: &'a str,
    position: usize,
    lines: Vec<&'a str>,
}

impl<'a> Parser<'a> {
    pub fn new(input: &'a str) -> Self {
        // TODO: 创建新的解析器
    }

    pub fn parse(&mut self) -> Result<Vec<AstNode<'a>>, ParseError> {
        // TODO: 解析整个文档
    }

    pub fn parse_line(&mut self, line: &'a str) -> Result<AstNode<'a>, ParseError> {
        // TODO: 解析单行
    }

    pub fn parse_heading(&self, line: &'a str) -> Option<AstNode<'a>> {
        // TODO: 解析标题 (# 标题)
    }

    pub fn parse_list(&self, line: &'a str) -> Option<AstNode<'a>> {
        // TODO: 解析列表 (- 或 1. )
    }

    pub fn parse_code_block(&mut self) -> Result<AstNode<'a>, ParseError> {
        // TODO: 解析代码块 (```code```)
    }

    pub fn parse_link(&self, text: &'a str) -> Option<AstNode<'a>> {
        // TODO: 解析链接 [text](url)
    }

    pub fn parse_image(&self, text: &'a str) -> Option<AstNode<'a>> {
        // TODO: 解析图片 ![alt](url)
    }
}
```

### 3. 渲染器

```rust
pub struct HtmlRenderer;

impl HtmlRenderer {
    pub fn render<'a>(nodes: &[AstNode<'a>]) -> String {
        // TODO: 渲染为 HTML
    }

    pub fn render_node<'a>(node: &AstNode<'a>) -> String {
        // TODO: 渲染单个节点
    }
}

pub struct MarkdownRenderer;

impl MarkdownRenderer {
    pub fn render<'a>(nodes: &[AstNode<'a>]) -> String {
        // TODO: 渲染为 Markdown
    }
}
```

### 4. 错误处理

```rust
#[derive(Debug, PartialEq)]
pub enum ParseError {
    UnexpectedEndOfInput,
    InvalidSyntax(String),
    UnknownLineType(usize),
}

impl std::fmt::Display for ParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        // TODO: 实现显示
    }
}

impl std::error::Error for ParseError {}
```

### 5. 文档结构

```rust
pub struct Document<'a> {
    nodes: Vec<AstNode<'a>>,
    metadata: Metadata<'a>,
}

pub struct Metadata<'a> {
    title: Option<&'a str>,
    author: Option<&'a str>,
    date: Option<&'a str>,
}

impl<'a> Document<'a> {
    pub fn new(nodes: Vec<AstNode<'a>>) -> Self {
        // TODO: 创建文档
    }

    pub fn with_metadata(mut self, metadata: Metadata<'a>) -> Self {
        // TODO: 添加元数据
    }

    pub fn render(&self, format: OutputFormat) -> String {
        // TODO: 渲染文档
    }
}

pub enum OutputFormat {
    Html,
    Markdown,
    PlainText,
}
```

### 6. 引用计数

```rust
pub struct Context<'a> {
    links: Vec<(&'a str, &'a str)>,  // (text, url)
    images: Vec<(&'a str, &'a str)>, // (alt, url)
}

impl<'a> Context<'a> {
    pub fn new() -> Self {
        // TODO: 创建新的上下文
    }

    pub fn add_link(&mut self, text: &'a str, url: &'a str) {
        // TODO: 添加链接
    }

    pub fn get_link(&self, text: &str) -> Option<&'a str> {
        // TODO: 获取链接 URL
    }

    pub fn add_image(&mut self, alt: &'a str, url: &'a str) {
        // TODO: 添加图片
    }
}
```

### 7. 块解析器

```rust
pub struct BlockParser<'a> {
    lines: std::slice::Iter<'a, &'a str>,
    current: Option<&'a str>,
}

impl<'a> BlockParser<'a> {
    pub fn new(lines: &'a [&'a str]) -> Self {
        // TODO: 创建块解析器
    }

    pub fn next_block(&mut self) -> Option<Vec<&'a str>> {
        // TODO: 读取下一个块
    }

    pub fn peek(&self) -> Option<&'a str> {
        // TODO: 查看下一行
    }

    pub fn is_empty(&self) -> bool {
        // TODO: 检查是否为空
    }
}
```

### 8. 行内解析器

```rust
pub struct InlineParser<'a> {
    text: &'a str,
    position: usize,
}

impl<'a> InlineParser<'a> {
    pub fn new(text: &'a str) -> Self {
        // TODO: 创建行内解析器
    }

    pub fn parse(&mut self) -> Vec<AstNode<'a>> {
        // TODO: 解析行内元素
    }

    pub fn parse_bold(&mut self) -> Option<AstNode<'a>> {
        // TODO: 解析粗体 **text**
    }

    pub fn parse_italic(&mut self) -> Option<AstNode<'a>> {
        // TODO: 解析斜体 *text*
    }

    pub fn parse_code(&mut self) -> Option<AstNode<'a>> {
        // TODO: 解析行内代码 `code`
    }
}
```

### 9. 表格支持

```rust
pub struct Table<'a> {
    headers: Vec<&'a str>,
    rows: Vec<Vec<&'a str>>,
}

impl<'a> Table<'a> {
    pub fn new(headers: Vec<&'a str>) -> Self {
        // TODO: 创建表格
    }

    pub fn add_row(&mut self, row: Vec<&'a str>) {
        // TODO: 添加行
    }

    pub fn render_html(&self) -> String {
        // TODO: 渲染为 HTML 表格
    }

    pub fn render_markdown(&self) -> String {
        // TODO: 渲染为 Markdown 表格
    }
}

pub fn parse_table<'a>(line: &'a str) -> Option<Table<'a>> {
    // TODO: 解析表格 | header | header |
}
```

### 10. 引用块

```rust
pub struct BlockQuote<'a> {
    lines: Vec<&'a str>,
    level: u8,
}

impl<'a> BlockQuote<'a> {
    pub fn new(lines: Vec<&'a str>) -> Self {
        // TODO: 创建引用块
    }

    pub fn render_html(&self) -> String {
        // TODO: 渲染为 HTML <blockquote>
    }

    pub fn render_markdown(&self) -> String {
        // TODO: 渲染为 Markdown > quote
    }
}
```

## 高级功能

### 11. 自定义容器

```rust
pub struct CustomContainer<'a> {
    name: &'a str,
    content: Vec<AstNode<'a>>,
    attributes: Vec<(&'a str, &'a str)>,
}

impl<'a> CustomContainer<'a> {
    pub fn new(name: &'a str) -> Self {
        // TODO: 创建自定义容器
    }

    pub fn with_attribute(mut self, key: &'a str, value: &'a str) -> Self {
        // TODO: 添加属性
    }

    pub fn parse(input: &'a str) -> Result<Self, ParseError> {
        // TODO: 解析 :::name 自定义容器
    }
}
```

### 12. 脚注

```rust
pub struct Footnote<'a> {
    id: &'a str,
    text: Vec<AstNode<'a>>,
}

pub struct FootnoteRef<'a> {
    id: &'a str,
}

pub struct FootnoteManager<'a> {
    footnotes: Vec<Footnote<'a>>,
    refs: Vec<FootnoteRef<'a>>,
}

impl<'a> FootnoteManager<'a> {
    pub fn new() -> Self {
        // TODO: 创建脚注管理器
    }

    pub fn add_footnote(&mut self, id: &'a str, text: Vec<AstNode<'a>>) {
        // TODO: 添加脚注
    }

    pub fn add_ref(&mut self, id: &'a str) {
        // TODO: 添加引用
    }

    pub fn render_html(&self) -> String {
        // TODO: 渲染脚注为 HTML
    }
}
```

### 13. 前言元数据

```rust
pub struct FrontMatter<'a> {
    data: std::collections::HashMap<&'a str, &'a str>,
}

impl<'a> FrontMatter<'a> {
    pub fn parse(input: &'a str) -> Result<(Self, &'a str), ParseError> {
        // TODO: 解析 --- 前言 ---
    }

    pub fn get(&self, key: &str) -> Option<&'a str> {
        // TODO: 获取值
    }
}
```

### 14. 生命周期标注的遍历器

```rust
pub struct AstIterator<'a, 'b>
where
    'a: 'b,
{
    nodes: std::slice::Iter<'b, AstNode<'a>>,
    stack: Vec<std::slice::Iter<'b, AstNode<'a>>>,
}

impl<'a, 'b> Iterator for AstIterator<'a, 'b>
where
    'a: 'b,
{
    type Item = &'b AstNode<'a>;

    fn next(&mut self) -> Option<Self::Item> {
        // TODO: 深度优先遍历 AST
    }
}
```

### 15. 类型擦除的渲染器

```rust
pub trait Renderer<'a> {
    fn render(&self, node: &AstNode<'a>) -> String;
}

pub struct BoxedRenderer<'a> {
    renderer: Box<dyn Renderer<'a> + 'a>,
}

impl<'a> BoxedRenderer<'a> {
    pub fn new<R: Renderer<'a> + 'a>(renderer: R) -> Self {
        // TODO: 创建类型擦除的渲染器
    }

    pub fn render(&self, node: &AstNode<'a>) -> String {
        // TODO: 调用内部渲染器
    }
}
```

## 测试要求

```rust
#[cfg(test)]
mod tests {
    use super::*;

    const SAMPLE_MD: &str = r#"
# Hello World

This is a **paragraph** with *emphasis*.

## Features

- Item 1
- Item 2
- Item 3

```rust
fn main() {
    println!("Hello");
}
```

[A link](https://example.com)
"#;

    #[test]
    fn test_parse_heading() {
        let parser = Parser::new("# Heading");
        assert!(matches!(parser.parse_line("Heading").unwrap(),
            AstNode::Heading { level: 1, .. }));
    }

    #[test]
    fn test_parse_document() {
        let mut parser = Parser::new(SAMPLE_MD);
        let doc = parser.parse().unwrap();
        assert!(!doc.is_empty());
    }

    #[test]
    fn test_html_rendering() {
        let nodes = vec![
            AstNode::Heading { level: 1, text: "Test" },
        ];
        let html = HtmlRenderer::render(&nodes);
        assert!(html.contains("<h1>"));
    }

    // TODO: 添加更多测试
}
```

## 性能考虑

1. **避免不必要的克隆**：使用引用而不是拥有字符串
2. **预分配容量**：`Vec::with_capacity()`
3. **零拷贝解析**：所有 AST 节点持有原始输入的引用
4. **生命周期优化**：最小化生命周期标注的复杂性

## 学习要点

通过这个综合练习，你将掌握：

- 复杂生命周期标注
- 多个生命周期参数
- 生命周期子类型
- 生命周期与 Trait 结合
- 类型别名使用
- 零拷贝解析技术
- 引用和生命周期在解析器中的应用

## 完成标准

- [ ] 所有单元测试通过
- [ ] 所有集成测试通过
- [ ] 代码通过 clippy 检查
- [ ] 正确使用生命周期避免克隆
- [ ] 代码格式化符合 rustfmt 标准
