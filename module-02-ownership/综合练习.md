# 综合练习：简易文本编辑器

## 项目简介

本综合练习需要你运用所有权系统的所有知识，实现一个简易的文本编辑器，支持文本的统计、修改和分析功能。

## 项目需求

### 功能描述

创建一个命令行文本编辑器程序，能够：
1. 读取和分析文本
2. 统计文本信息（字数、字符数等）
3. 执行文本修改操作
4. 查找和替换功能

### 具体要求

#### 1. 核心数据结构

```rust
pub struct TextEditor {
    content: String,
}
```

#### 2. 必须实现的功能

**基础功能**：

1. `new() -> Self`
   - 创建新的空编辑器

2. `load(text: String) -> Self`
   - 加载文本（获取所有权）
   - 演示所有权转移

3. `get_content(&self) -> &str`
   - 获取内容引用（不转移所有权）

4. `word_count(&self) -> usize`
   - 统计单词数量
   - 使用引用而非转移所有权

5. `char_count(&self) -> usize`
   - 统计字符数量
   - 正确处理 Unicode

6. `line_count(&self) -> usize`
   - 统计行数

**中级功能**：

7. `append(&mut self, text: &str)`
   - 追加文本
   - 演示可变借用

8. `prepend(&mut self, text: &str)`
   - 在开头插入文本

9. `get_line(&self, index: usize) -> Option<&str>`
   - 获取指定行
   - 返回切片，不拷贝数据
   - 使用生命周期

10. `find<'a>(&'a self, pattern: &str) -> Option<&'a str>`
    - 查找文本
    - 返回匹配的切片
    - 正确标注生命周期

**高级功能**：

11. `replace(&mut self, from: &str, to: &str) -> usize`
    - 替换所有匹配的文本
    - 返回替换次数

12. `delete_line(&mut self, index: usize) -> bool`
    - 删除指定行
    - 返回是否成功

13. `trim(&mut self)`
    - 删除首尾空白

14. `split_at_word(&self, index: usize) -> (&str, &str)`
    - 在指定单词处分割文本
    - 返回两个切片的元组
    - 避免数据拷贝

### 3. 示例使用

```rust
fn main() {
    // 创建编辑器
    let mut editor = TextEditor::new();

    // 加载文本
    let text = String::from("Hello Rust World\nThis is ownership");
    editor = TextEditor::load(text);

    // 统计信息
    println!("单词数: {}", editor.word_count());
    println!("字符数: {}", editor.char_count());
    println!("行数: {}", editor.line_count());

    // 追加文本
    editor.append("\nWelcome to Rust");

    // 查找
    if let Some(found) = editor.find("Rust") {
        println!("找到: {}", found);
    }

    // 替换
    let count = editor.replace("Rust", "Rust Programming");
    println!("替换了 {} 处", count);

    // 获取行
    if let Some(line) = editor.get_line(0) {
        println!("第一行: {}", line);
    }

    // 显示完整内容
    println!("\n完整文本:\n{}", editor.get_content());
}
```

### 4. 测试用例

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_word_count() {
        let editor = TextEditor::load(String::from("Hello World Rust"));
        assert_eq!(editor.word_count(), 3);
    }

    #[test]
    fn test_char_count() {
        let editor = TextEditor::load(String::from("Hello"));
        assert_eq!(editor.char_count(), 5);
    }

    #[test]
    fn test_line_count() {
        let editor = TextEditor::load(String::from("Line1\nLine2\nLine3"));
        assert_eq!(editor.line_count(), 3);
    }

    #[test]
    fn test_append() {
        let mut editor = TextEditor::load(String::from("Hello"));
        editor.append(" World");
        assert_eq!(editor.get_content(), "Hello World");
    }

    #[test]
    fn test_replace() {
        let mut editor = TextEditor::load(String::from("Hello Rust World"));
        let count = editor.replace("Rust", "Rustacean");
        assert_eq!(count, 1);
        assert!(editor.get_content().contains("Rustacean"));
    }

    #[test]
    fn test_find() {
        let editor = TextEditor::load(String::from("Hello Rust World"));
        assert!(editor.find("Rust").is_some());
        assert!(editor.find("Python").is_none());
    }

    #[test]
    fn test_ownership_transfer() {
        let text = String::from("Hello World");
        let editor = TextEditor::load(text);
        // text 已失效，所有权转移给 editor
        // assert_eq!(text, "Hello World");  // 这行会编译错误
    }
}
```

## 验收标准

### 功能要求

- [ ] 所有 14 个功能都正确实现
- [ ] 函数正确使用引用和所有权
- [ ] 没有不必要的内存拷贝
- [ ] 生命周期标注正确

### 代码质量

- [ ] 所有单元测试通过
- [ ] 代码通过 `cargo clippy` 检查（无警告）
- [ ] 代码格式化 `cargo fmt`
- [ ] 没有编译警告

### 所有权要求

- [ ] 正确区分移动和拷贝的场景
- [ ] 正确使用不可变引用 `&T`
- [ ] 正确使用可变引用 `&mut T`
- [ ] 遵守借用规则（无数据竞争）
- [ ] 无悬垂引用
- [ ] 切片使用正确，避免越界

### 性能要求

- [ ] 避免不必要的 `clone()`
- [ ] 尽量使用引用而非获取所有权
- [ ] 切片操作不拷贝数据

## 实现步骤

1. **创建文件结构**：
   ```bash
   module-02-ownership/
   ├── src/
   │   └── lib.rs
   ├── examples/
   │   └── text_editor.rs
   └── tests/
       └── mod.rs
   ```

2. **实现核心结构体**：
   - 定义 `TextEditor` 结构体
   - 实现构造函数

3. **逐个实现功能**：
   - 从简单的统计功能开始
   - 逐步实现修改功能
   - 最后实现高级功能

4. **编写测试**：
   - 每个功能都有对应测试
   - 包括边界情况测试

5. **运行验证**：
   ```bash
   # 编译检查
   cargo build -p module-02-ownership

   # 运行测试
   cargo test -p module-02-ownership

   # 运行示例
   cargo run -p module-02-ownership --example text_editor

   # 代码检查
   cargo clippy -p module-02-ownership

   # 格式化
   cargo fmt -p module-02-ownership
   ```

## 扩展挑战（可选）

完成基础要求后，可以尝试以下扩展：

1. **撤销功能**：
   - 添加历史记录栈
   - 实现 `undo()` 方法
   - 使用 Vec 存储历史状态

2. **多光标编辑**：
   - 同时编辑多个位置
   - 使用切片范围

3. **搜索并高亮**：
   - 查找所有匹配位置
   - 返回匹配位置的 Vec

4. **性能优化**：
   - 使用 `Cow<str>` 避免不必要的分配
   - 使用 `Rc<str>` 或 `Arc<str>` 共享数据

## 提示

<details>
<summary>所有权使用提示</summary>

1. **何时移动**：
   - 函数需要持有数据
   - 构造函数接收数据

2. **何时使用引用**：
   - 只需要读取数据
   - 只需要临时修改
   - 返回数据的部分视图

3. **生命周期标注**：
   ```rust
   pub fn get_line<'a>(&'a self, index: usize) -> Option<&'a str> {
       // 'a 表示返回的引用与 self 的生命周期相关
   }
   ```

4. **避免克隆**：
   - 优先使用 `&str` 而非 `String`
   - 使用切片返回部分数据
   - 使用迭代器处理数据
</details>

<details>
<summary>切片使用提示</summary>

1. **字符串切片**：
   ```rust
   let s = &self.content[start..end];
   ```

2. **按行分割**：
   ```rust
   let lines: Vec<&str> = self.content.lines().collect();
   ```

3. **按单词分割**：
   ```rust
   let words: Vec<&str> = self.content.split_whitespace().collect();
   ```

4. **查找模式**：
   ```rust
   if let Some(pos) = self.content.find(pattern) {
       return Some(&self.content[pos..pos + pattern.len()]);
   }
   ```
</details>

## 参考实现

完成项目后，可以查看 `solutions/text_editor.rs` 中的参考实现。

## 学习目标

通过本项目，你将：

1. **深入理解所有权**：
   - 何时转移所有权
   - 何时使用引用
   - 如何避免不必要的拷贝

2. **掌握借用规则**：
   - 不可变借用的使用场景
   - 可变借用的使用场景
   - 如何避免违反借用规则

3. **熟练使用切片**：
   - 字符串切片
   - 避免越界
   - 返回切片而非拷贝数据

4. **生命周期管理**：
   - 正确标注生命周期
   - 理解生命周期之间的关系
   - 避免悬垂引用

## 常见问题

### Q: 为什么要返回 `&str` 而不是 `String`？

A: 返回 `&str` 避免了内存分配和数据拷贝，更高效。如果调用者只需要读取数据，不需要拥有它，就应该返回引用。

### Q: 什么时候需要生命周期标注？

A: 当函数返回引用，且引用与输入参数的生命周期相关时，需要标注生命周期。编译器通常会提示你添加。

### Q: 如何避免不必要的克隆？

A: 使用引用传递数据，使用切片返回部分数据，使用迭代器处理数据。只在必要时使用 `clone()`。

### Q: 借用检查器报错怎么办？

A: 检查是否同时存在可变和不可变引用，检查引用的生命周期是否足够长。使用 `{}` 创建作用域来控制引用的生命周期。
