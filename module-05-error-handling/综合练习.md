# 综合练习：配置文件解析器

## 项目描述

创建一个健壮的配置文件解析器，能够：
1. 读取配置文件
2. 解析不同类型的值
3. 处理各种错误情况
4. 提供清晰的错误消息

## 项目结构

```
综合练习/
├── src/
│   ├── lib.rs          # 主库文件
│   ├── parser.rs       # 配置解析器
│   └── error.rs        # 错误类型定义
└── tests/
    └── integration.rs  # 集成测试
```

## 需求

### 1. 自定义错误类型

使用 `thiserror` 定义分层错误类型：

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ConfigError {
    #[error("IO 错误: {path}: {source}")]
    Io {
        path: String,
        #[source] std::io::Error,
    },

    #[error("解析错误: {path}:{line}: {message}")]
    Parse {
        path: String,
        line: usize,
        message: String,
    },

    #[error("验证错误: {key}: {message}")]
    Validation {
        key: String,
        message: String,
    },

    #[error("类型错误: {key}: 期望 {expected}, 得到 {got}")]
    TypeMismatch {
        key: String,
        expected: String,
        got: String,
    },

    #[error("缺少必需的配置: {key}")]
    MissingKey {
        key: String,
    },
}
```

### 2. 配置值类型

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum ConfigValue {
    String(String),
    Integer(i64),
    Float(f64),
    Boolean(bool),
}

impl ConfigValue {
    pub fn as_string(&self) -> Result<&str, ConfigError> { }
    pub fn as_integer(&self) -> Result<i64, ConfigError> { }
    pub fn as_float(&self) -> Result<f64, ConfigError> { }
    pub fn as_bool(&self) -> Result<bool, ConfigError> { }
}
```

### 3. 配置解析器

```rust
pub struct Config {
    values: HashMap<String, ConfigValue>,
}

impl Config {
    /// 从文件加载配置
    pub fn from_file(path: &str) -> Result<Self, ConfigError> {
        // 1. 读取文件（处理 IO 错误）
        // 2. 解析内容（处理解析错误）
        // 3. 验证配置（处理验证错误）
    }

    /// 获取字符串值
    pub fn get_string(&self, key: &str) -> Result<&str, ConfigError> {
        match self.values.get(key) {
            Some(value) => value.as_string(),
            None => Err(ConfigError::MissingKey {
                key: key.to_string(),
            }),
        }
    }

    /// 获取必需的配置值
    pub fn require<T>(&self, key: &str) -> Result<T, ConfigError>
    where
        ConfigValue: TryInto<T, Error = ConfigError>,
    {
        // 使用 TryInto trait 进行类型转换
    }

    /// 获取可选的配置值
    pub fn get_optional<T>(&self, key: &str) -> Result<Option<T>, ConfigError>
    where
        ConfigValue: TryInto<T, Error = ConfigError>,
    {
        // 类似 require，但允许缺失
    }
}
```

### 4. 解析格式

支持简单的键值对格式：

```ini
# 注释
database_url = postgresql://localhost/mydb
max_connections = 100
enable_ssl = true
timeout = 30.5
```

### 5. 类型推断

```rust
impl Config {
    fn parse_value(key: &str, value: &str) -> ConfigValue {
        // "true" / "false" -> Boolean
        // 纯数字 -> Integer
        // 带小数点的数字 -> Float
        // 其他 -> String
    }
}
```

### 6. 验证规则

```rust
impl Config {
    pub fn validate(&self) -> Result<(), ConfigError> {
        // 检查必需的键
        // 验证值的范围
        // 检查依赖关系
    }

    fn validate_port(&self, key: &str) -> Result<(), ConfigError> {
        let port = self.get_integer(key)?;
        if !(1..=65535).contains(&port) {
            return Err(ConfigError::Validation {
                key: key.to_string(),
                message: format!("端口 {} 超出范围 1-65535", port),
            });
        }
        Ok(())
    }
}
```

### 7. 错误链

```rust
impl Config {
    pub fn load_with_context(base_path: &str) -> Result<Self, ConfigError> {
        // 使用 ? 自动转换错误
        let content = std::fs::read_to_string(base_path)
            .map_err(|e| ConfigError::Io {
                path: base_path.to_string(),
                source: e,
            })?;

        // 添加更多上下文
        let config: Self = content.parse()
            .map_err(|e| ConfigError::Parse {
                path: base_path.to_string(),
                line: 0,
                message: e.to_string(),
            })?;

        config.validate()?;
        Ok(config)
    }
}
```

## 测试要求

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_valid_config() {
        let content = r#"
            host = localhost
            port = 8080
            debug = true
        "#;
        // 验证解析正确
    }

    #[test]
    fn test_missing_key() {
        let config = Config::new();
        let result = config.get_string("missing_key");
        assert!(matches!(result, Err(ConfigError::MissingKey { .. })));
    }

    #[test]
    fn test_type_mismatch() {
        // 尝试将字符串当作整数读取
    }

    #[test]
    fn test_error_chain() {
        // 测试错误消息是否包含完整的上下文
    }

    #[test]
    fn test_validation() {
        // 测试端口验证
        // 测试必需字段检查
    }
}
```

## 实用功能

### 1. 默认值

```rust
impl Config {
    pub fn get_or_default<T>(&self, key: &str, default: T) -> Result<T, ConfigError>
    where
        T: Clone,
        ConfigValue: TryInto<T, Error = ConfigError>,
    {
        self.get_optional(key)?
            .ok_or_else(|| ConfigError::MissingKey { key: key.to_string() })
    }
}
```

### 2. 环境变量覆盖

```rust
impl Config {
    pub fn with_env_override(mut self) -> Result<Self, ConfigError> {
        // 从环境变量读取值，覆盖配置文件
        // 例如：MYAPP_PORT -> port
    }
}
```

### 3. 配置合并

```rust
impl Config {
    pub fn merge(&mut self, other: Config) -> Result<(), ConfigError> {
        // 合并两个配置，后者覆盖前者
        // 处理冲突
    }
}
```

## 最佳实践

1. **错误消息要清晰**
   - 包含足够的上下文信息
   - 指出如何修复问题

2. **使用 thiserror**
   - 自动实现 Display 和 Error
   - 支持错误链

3. **提供多种获取值的方式**
   - require: 必需的值
   - get_optional: 可选的值
   - get_or_default: 带默认值

4. **早期验证**
   - 加载后立即验证配置
   - 不要等到使用时才发现错误

5. **类型安全**
   - 使用 ConfigValue 枚举而不是字符串
   - 实现严格的类型转换

## 挑战任务

1. **支持嵌套配置** (database.url)
2. **支持数组** (servers = [a, b, c])
3. **支持环境变量展开** (${HOME})
4. **配置热重载**
5. **配置文件监听**

## 学习要点

通过这个综合练习，你将掌握：

- 使用 thiserror 定义复杂的错误类型
- 错误传播和转换
- 提供清晰的错误消息
- 类型安全的配置访问
- 链式错误处理

## 完成标准

- [ ] 所有单元测试通过
- [ ] 所有集成测试通过
- [ ] 错误消息清晰有用
- [ ] 代码通过 clippy 检查
- [ ] 添加适当的文档注释
