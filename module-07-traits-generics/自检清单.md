# 07-Trait 与泛型 - 自检清单

## Trait 基础

- [ ] 理解 Trait 的作用和概念
- [ ] 能够定义自己的 Trait
- [ ] 能够为类型实现 Trait
- [ ] 理解默认实现
- [ ] 能够调用 Trait 方法

## Trait Bound

- [ ] 理解 Trait Bound 的语法 `<T: Trait>`
- [ ] 能够使用多个 Trait Bound `<T: Trait1 + Trait2>`
- [ ] 能够使用 where 子句
- [ ] 理解 `impl Trait` 语法
- [ ] 能够返回 `impl Trait`

## 泛型

- [ ] 理解泛型的概念
- [ ] 能够定义泛型函数
- [ ] 能够定义泛型结构体
- [ ] 能够定义泛型枚举
- [ ] 能够定义泛型方法
- [ ] 理解泛型性能（单态化）

## 生命周期

- [ ] 理解生命周期的概念
- [ ] 能够标注生命周期参数
- [ ] 理解生命周期省略规则
- [ ] 能够在函数中使用生命周期
- [ ] 能够在结构体中使用生命周期
- [ ] 理解 `'static` 生命周期

## 标准库 Trait

### Display & Debug
- [ ] 理解 `{}` 和 `{:?}` 的区别
- [ ] 能够实现 Display trait
- [ ] 能够实现 Debug trait（使用 `#[derive(Debug)]`）

### Clone & Copy
- [ ] 理解 Clone 和 Copy 的区别
- [ ] 能够实现 Clone trait
- [ ] 理解哪些类型可以实现 Copy
- [ ] 能够使用 `#[derive(Copy, Clone)]`

### PartialEq & Eq
- [ ] 理解 PartialEq 和 Eq 的区别
- [ ] 能够实现 PartialEq trait
- [ ] 理解 `#[derive(PartialEq, Eq)]`

### PartialOrd & Ord
- [ ] 理解 PartialOrd 和 Ord 的区别
- [ ] 能够实现 PartialOrd trait
- [ ] 能够使用 Ordering 枚举

### Default
- [ ] 理解 Default trait 的作用
- [ ] 能够实现 Default trait
- [ ] 理解 `..Default::default()` 语法

### Iterator
- [ ] 理解 Iterator trait
- [ ] 能够创建自定义迭代器
- [ ] 理解关联类型 `Item`
- [ ] 能够使用迭代器适配器

### From & Into
- [ ] 理解 From 和 Into 的关系
- [ ] 能够实现 From trait
- [ ] 理解 Into 是自动实现的

### AsRef & AsMut
- [ ] 理解 AsRef 和 AsMut 的作用
- [ ] 能够实现 AsRef trait

## 高级特性

### 关联类型
- [ ] 理解关联类型 vs 泛型参数
- [ ] 能够定义带关联类型的 Trait
- [ ] 理解何时使用关联类型

### 默认类型参数
- [ ] 理解默认泛型参数
- [ ] 能够使用默认类型参数

### Trait 对象
- [ ] 理解动态分发 vs 静态分发
- [ ] 能够使用 `dyn Trait`
- [ ] 理解 Trait 对象的限制
- [ ] 理解对象安全

### 运算符重载
- [ ] 理解可以重载的运算符
- [ ] 能够实现 `Add` trait
- [ ] 能够实现其他运算符 trait

### Fn 系列 Trait
- [ ] 理解 `Fn`, `FnMut`, `FnOnce` 的区别
- [ ] 理解闭包如何实现这些 Trait
- [ ] 能够接受函数作为参数

### supertrait
- [ ] 理解 supertrait 概念
- [ ] 能够使用 `trait Trait: SuperTrait {}`

### 孤儿规则
- [ ] 理解孤儿规则的限制
- [ ] 知道何时可以或不能实现 Trait

## 实践能力

- [ ] 能够设计良好的 Trait
- [ ] 能够合理使用泛型避免代码重复
- [ ] 能够解决生命周期编译错误
- [ ] 能够使用 Trait 对象实现多态
- [ ] 能够为类型实现标准库 Trait
- [ ] 能够使用 Trait Bound 编写灵活的函数

## 常见模式

- [ ] Builder 模式（使用 Trait）
- [ ] 策略模式（使用 Trait 对象）
- [ ] 迭代器模式（实现 Iterator）
- [ ] 适配器模式（使用泛型）

## 调试技巧

- [ ] 能够理解生命周期错误信息
- [ ] 能够理解 Trait Bound 错误信息
- [ ] 能够使用 `#[derive(..)]` 简化代码
- [ ] 能够使用类型推导减少标注

## 性能考虑

- [ ] 理解泛型的零成本抽象
- [ ] 理解 Trait 对象的性能开销
- [ ] 知道何时使用泛型 vs Trait 对象

## 测试

通过以下测试验证理解：

```rust
// 1. 基础 Trait
trait Drawable {
    fn draw(&self) -> String;
}

// 2. 泛型函数
fn largest<T: PartialOrd>(list: &[T]) -> &T {
    // 实现
}

// 3. 生命周期
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    // 实现
}

// 4. Trait Bound
fn compare_print<T: Display + Debug>(item: &T) {
    // 实现
}

// 5. 关联类型
trait Container {
    type Item;
    fn get(&self, index: usize) -> Option<&Self::Item>;
}

// 6. impl Trait
fn get_iterator() -> impl Iterator<Item = i32> {
    // 实现
}
```

## 自测问题

1. Trait 和其他语言的接口有什么区别？
2. 什么时候使用泛型，什么时候使用 Trait 对象？
3. 生命周期的三个省略规则是什么？
4. `Fn`, `FnMut`, `FnOnce` 有什么区别？
5. 关联类型比泛型参数有什么优势？
6. 为什么需要孤儿规则？
7. `'static` 生命周期意味着什么？
8. 如何决定使用 `Clone` 还是 `Copy`？
9. Trait 对象有什么限制？
10. 如何为闭包指定 Trait Bound？
