# 综合练习：简单配置解析器

## 项目描述

创建一个简单的配置文件解析器，支持解析键值对配置，并使用模式匹配处理不同类型的值。

## 项目结构

```
综合练习/
├── src/
│   ├── lib.rs          # 主库文件
│   ├── parser.rs       # 配置解析器
│   └── config.rs       # 配置类型定义
└── tests/
    └── integration.rs  # 集成测试
```

## 需求

### 1. 配置类型定义

定义配置值枚举和配置结构：

```rust
pub enum ConfigValue {
    String(String),
    Integer(i64),
    Float(f64),
    Boolean(bool),
    List(Vec<ConfigValue>),
}

pub struct Config {
    entries: HashMap<String, ConfigValue>,
}
```

### 2. 解析功能

实现解析器，支持以下格式：

```ini
# 注释
name = Alice
age = 30
height = 1.68
active = true
tags = rust,programming,tutorial
score = 95
```

### 3. 模式匹配要求

在以下场景中使用模式匹配：

#### 场景 1: 获取配置值

```rust
impl Config {
    pub fn get(&self, key: &str) -> Option<&ConfigValue> {
        self.entries.get(key)
    }

    pub fn get_string(&self, key: &str) -> Result<Option<&str>, ConfigError> {
        match self.get(key) {
            None => Ok(None),
            Some(ConfigValue::String(s)) => Ok(Some(s)),
            Some(_) => Err(ConfigError::TypeMismatch),
        }
    }

    // 类似实现 get_integer, get_float, get_boolean
}
```

#### 场景 2: 设置配置值

```rust
pub fn parse_value(input: &str) -> Result<ConfigValue, ParseError> {
    // 使用模式匹配识别不同类型：
    // - 布尔值: true, false
    // - 整数: 可选的 +/- 后跟数字
    // - 浮点数: 包含小数点
    // - 列表: 逗号分隔的值
    // - 字符串: 其他所有
    todo!()
}
```

#### 场景 3: 格式化输出

```rust
impl Display for ConfigValue {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            ConfigValue::String(s) => write!(f, "\"{}\"", s),
            ConfigValue::Integer(n) => write!(f, "{}", n),
            ConfigValue::Float(n) => write!(f, "{}", n),
            ConfigValue::Boolean(b) => write!(f, "{}", b),
            ConfigValue::List(items) => {
                // 格式化为 [item1, item2, ...]
                todo!()
            }
        }
    }
}
```

### 4. 错误处理

定义错误类型：

```rust
pub enum ConfigError {
    KeyNotFound(String),
    TypeMismatch,
    InvalidValue(String),
}

pub enum ParseError {
    InvalidSyntax,
    UnsupportedType,
}
```

### 5. 实用功能

使用模式匹配实现：

```rust
impl Config {
    // 合并两个配置
    pub fn merge(&mut self, other: Config) {
        for (key, value) in other.entries {
            match self.entries.get(&key) {
                None => { self.entries.insert(key, value); }
                Some(ConfigValue::List(existing)) => {
                    // 如果都是列表，合并
                    if let ConfigValue::List(new_items) = value {
                        // 合并列表
                    }
                }
                _ => { self.entries.insert(key, value); }
            }
        }
    }

    // 获取嵌套值
    pub fn get_nested(&self, key: &str) -> Option<&ConfigValue> {
        // 支持 "a.b.c" 格式的键
        todo!()
    }
}
```

## 测试要求

### 单元测试

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_string() {
        let value = parse_value("hello").unwrap();
        assert!(matches!(value, ConfigValue::String(_)));
    }

    #[test]
    fn test_parse_integer() {
        let value = parse_value("42").unwrap();
        assert_eq!(value, ConfigValue::Integer(42));
    }

    #[test]
    fn test_parse_boolean() {
        assert_eq!(parse_value("true").unwrap(), ConfigValue::Boolean(true));
        assert_eq!(parse_value("false").unwrap(), ConfigValue::Boolean(false));
    }

    #[test]
    fn test_parse_list() {
        let value = parse_value("a,b,c").unwrap();
        assert!(matches!(value, ConfigValue::List(_)));
    }

    #[test]
    fn test_config_get_string() {
        let mut config = Config::new();
        config.set("name", ConfigValue::String("Alice".to_string()));
        assert_eq!(config.get_string("name").unwrap(), Some("Alice"));
    }

    #[test]
    fn test_config_get_string_type_mismatch() {
        let mut config = Config::new();
        config.set("age", ConfigValue::Integer(30));
        assert!(matches!(
            config.get_string("age"),
            Err(ConfigError::TypeMismatch)
        ));
    }

    #[test]
    fn test_merge_configs() {
        let mut config1 = Config::new();
        config1.set("a", ConfigValue::Integer(1));

        let mut config2 = Config::new();
        config2.set("b", ConfigValue::Integer(2));

        config1.merge(config2);
        assert_eq!(config1.get_integer("a").unwrap(), Some(&1));
        assert_eq!(config1.get_integer("b").unwrap(), Some(&2));
    }

    #[test]
    fn test_merge_lists() {
        let mut config1 = Config::new();
        config1.set("tags", ConfigValue::List(vec![
            ConfigValue::String("rust".to_string())
        ]));

        let mut config2 = Config::new();
        config2.set("tags", ConfigValue::List(vec![
            ConfigValue::String("programming".to_string())
        ]));

        config1.merge(config2);
        // 验证列表已合并
    }
}
```

### 集成测试

测试完整的工作流程：

```rust
#[test]
fn test_parse_config_file() {
    let config_text = r#"
        name = Bob
        age = 25
        active = true
        tags = rust,tutorial
    "#;

    let config = Config::parse(config_text).unwrap();
    assert_eq!(config.get_string("name").unwrap(), Some("Bob"));
    assert_eq!(config.get_integer("age").unwrap(), Some(&25));
    assert_eq!(config.get_boolean("active").unwrap(), Some(&true));
}

#[test]
fn test_config_manipulation() {
    let mut config = Config::new();

    // 设置不同类型的值
    config.set("name", ConfigValue::String("Alice".to_string()));
    config.set("count", ConfigValue::Integer(10));
    config.set("rate", ConfigValue::Float(3.14));
    config.set("enabled", ConfigValue::Boolean(true));

    // 验证类型安全获取
    assert!(config.get_string("name").is_ok());
    assert!(config.get_integer("count").is_ok());
    assert!(config.get_float("rate").is_ok());
    assert!(config.get_boolean("enabled").is_ok());
}
```

## 挑战任务

1. **支持环境变量替换**: `${VAR}` 语法
2. **支持引用**: `${other.key}` 引用其他键
3. **类型转换**: 自动尝试类型转换
4. **验证**: 添加模式验证规则

## 学习要点

通过这个综合练习，你将掌握：

- 使用枚举表示不同类型的值
- 使用模式匹配处理复杂的类型判断
- 使用 if let 简化单模式匹配
- 使用解构访问复杂数据
- 使用守卫添加额外条件
- 使用 @ 绑定保留匹配的值

## 完成标准

- [ ] 所有单元测试通过
- [ ] 所有集成测试通过
- [ ] 代码通过 clippy 检查
- [ ] 使用模式匹配处理所有类型判断
- [ ] 代码格式化符合 rustfmt 标准
- [ ] 添加适当的文档注释
