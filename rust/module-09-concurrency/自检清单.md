# 09-并发编程 - 自检清单

## 线程基础

- [ ] 理解线程的概念
- [ ] 能够创建新线程
- [ ] 能够使用 join 等待线程完成
- [ ] 理解线程的闭包捕获
- [ ] 知道 move 关键字的作用

## 消息传递

- [ ] 理解 channel 的概念
- [ ] 能够创建 mpsc channel
- [ ] 能够发送和接收消息
- [ ] 理解发送者和接收者的关系
- [ ] 能够处理 channel 关闭

## 共享状态

- [ ] 理解 Mutex 的概念
- [ ] 能够使用 Mutex 保护数据
- [ ] 理解 lock() 和 unwrap()
- [ ] 能够使用 Arc 共享所有权
- [ ] 理解死锁的概念

## RwLock

- [ ] 理解 RwLock 的读写分离
- [ ] 知道何时使用 RwLock 而非 Mutex
- [ ] 能够使用 read() 和 write()
- [ ] 理解读写锁的规则

## 原子类型

- [ ] 理解原子类型的概念
- [ ] 能够使用 AtomicUsize 等
- [ ] 理解 Ordering 参数
- [ ] 知道何时使用原子类型

## Send 和 Sync

- [ ] 理解 Send trait 的含义
- [ ] 理解 Sync trait 的含义
- [ ] 知道哪些类型自动实现 Send/Sync
- [ ] 理解为什么 Rc 不是 Send/Sync

## 并发模式

- [ ] 理解生产者-消费者模式
- [ ] 理解工作队列模式
- [ ] 理解屏障同步模式
- [ ] 能够实现简单线程池

## 实践能力

- [ ] 能够创建多线程程序
- [ ] 能够使用 channel 通信
- [ ] 能够使用 Mutex 保护共享数据
- [ ] 能够使用 Arc 在线程间共享
- [ ] 能够识别和避免死锁

## 常见模式

- [ ] 线程池模式
- [ ] 生产者-消费者
- [ ] 工作窃取
- [ ] 读写锁
- [ ] 原子计数器

## 调试技巧

- [ ] 能够识别数据竞争
- [ ] 能够识别死锁
- [ ] 能够使用工具检测并发问题
- [ ] 知道如何避免常见陷阱

## 性能考虑

- [ ] 理解线程创建开销
- [ ] 理解上下文切换开销
- [ ] 知道何时使用并发
- [ ] 理解 Amdahl 定律

## 测试

通过以下测试验证理解：

```rust
// 1. 创建线程
use std::thread;

let handle = thread::spawn(|| {
    42
});
assert_eq!(handle.join().unwrap(), 42);

// 2. Channel
use std::sync::mpsc;

let (tx, rx) = mpsc::channel();
tx.send(42).unwrap();
assert_eq!(rx.recv().unwrap(), 42);

// 3. Mutex
use std::sync::{Arc, Mutex};

let m = Arc::new(Mutex::new(0));
let m_clone = Arc::clone(&m);
thread::spawn(move || {
    *m_clone.lock().unwrap() = 42;
});
handle.join().unwrap();
assert_eq!(*m.lock().unwrap(), 42);

// 4. RwLock
use std::sync::RwLock;

let rw = RwLock::new(5);
{
    let r1 = rw.read().unwrap();
    let r2 = rw.read().unwrap();
    assert_eq!(*r1, 5);
    assert_eq!(*r2, 5);
} // 读锁在这里释放

// 5. 原子类型
use std::sync::atomic::{AtomicUsize, Ordering};

let atom = AtomicUsize::new(0);
atom.fetch_add(1, Ordering::SeqCst);
assert_eq!(atom.load(Ordering::SeqCst), 1);
```

## 自测问题

1. 为什么需要 move 关键字？
2. channel 的发送者和接收者有什么特点？
3. Mutex 和 RwLock 有什么区别？
4. 为什么需要 Arc 而不是 Rc？
5. 什么是死锁？如何避免？
6. Send 和 Sync 有什么区别？
7. 原子类型的 Ordering 参数有什么用？
8. 如何在线程间传递结果？
9. 线程池有什么优势？
10. 如何检测数据竞争？
11. 什么情况下使用并发？
12. 如何控制并发数量？
13. Barrier 是用来做什么的？
14. 如何实现超时控制？
15. 工作窃取是如何工作的？
