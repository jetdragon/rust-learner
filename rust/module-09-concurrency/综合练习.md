# 综合练习：并行计算框架

## 项目描述

创建一个简单的并行计算框架，演示 Rust 并发编程的综合应用。

## 项目结构

```
综合练习/
├── src/
│   ├── lib.rs          # 主库文件
│   ├── thread_pool.rs  # 线程池
│   ├── task.rs         # 任务定义
│   ├── result.rs       # 结果收集
│   └── worker.rs       # 工作线程
└── tests/
    └── integration.rs  # 集成测试
```

## 核心需求

### 1. 线程池实现

```rust
use std::sync::{mpsc, Arc, Mutex};

pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Message>,
}

type Job = Box<dyn FnOnce() -> Result + Send + 'static>;
type Result = Box<dyn Any + Send + 'static>;

enum Message {
    NewJob(Job),
    Terminate,
}

impl ThreadPool {
    pub fn new(size: usize) -> Self {
        // TODO: 创建指定大小的线程池
        assert!(size > 0);

        // TODO: 创建 channel
        // TODO: 创建并启动工作线程
    }

    pub fn execute<F, R>(&self, f: F) -> Result
    where
        F: FnOnce() -> R + Send + 'static,
        R: Any + Send + 'static,
    {
        // TODO: 发送任务到线程池
        // TODO: 返回 Result 用于获取结果
    }
}

impl Drop for ThreadPool {
    fn drop(&mut self) {
        // TODO: 发送终止消息给所有线程
        // TODO: 等待所有线程完成
    }
}
```

### 2. 工作线程

```rust
struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Message>>>) -> Self {
        // TODO: 创建新工作线程
        // 线程循环接收消息并执行任务
    }
}
```

### 3. 并行迭代器

```rust
pub struct ParallelIterator<T> {
    items: Vec<T>,
    thread_pool: Arc<ThreadPool>,
}

impl<T> ParallelIterator<T>
where
    T: Send + 'static,
{
    pub fn new(items: Vec<T>) -> Self {
        // TODO: 创建并行迭代器
    }

    pub fn map<F, R>(self, f: F) -> Vec<R>
    where
        F: Fn(T) -> R + Send + Copy + 'static,
        R: Send + 'static,
    {
        // TODO: 并行应用函数到每个元素
    }

    pub fn filter<F>(self, f: F) -> Vec<T>
    where
        F: Fn(&T) -> bool + Send + Copy + 'static,
    {
        // TODO: 并行过滤元素
    }

    pub fn reduce<F>(self, identity: T, f: F) -> T
    where
        F: Fn(T, T) -> T + Send + Copy + 'static,
        T: Clone + Send + 'static,
    {
        // TODO: 并行归约操作
    }
}
```

### 4. 结果收集器

```rust
pub struct ResultCollector<T> {
    results: Arc<Mutex<Vec<T>>>,
    expected: usize,
}

impl<T> ResultCollector<T>
where
    T: Send + 'static,
{
    pub fn new(expected: usize) -> Self {
        // TODO: 创建结果收集器
    }

    pub fn collect(&self, result: T) {
        // TODO: 线程安全地收集结果
    }

    pub fn wait_for_all(&self) -> Vec<T> {
        // TODO: 等待所有结果完成
    }

    pub fn is_complete(&self) -> bool {
        // TODO: 检查是否所有结果都已收集
    }
}
```

### 5. 并行排序

```rust
pub fn parallel_sort<T>(numbers: Vec<T>) -> Vec<T>
where
    T: Ord + Send + 'static,
{
    // TODO: 实现并行归并排序
    // 提示: 使用 divide and conquer + threads
}
```

### 6. 并行搜索

```rust
pub fn parallel_search<T>(items: Vec<T>, target: T) -> Option<usize>
where
    T: PartialEq<T> + Send + Sync + 'static,
{
    // TODO: 实现并行搜索
    // 提示: 分段搜索，合并结果
}
```

### 7. 并行 Map-Reduce

```rust
pub fn map_reduce<K, V, R, M, F>(
    items: Vec<V>,
    map_fn: M,
    reduce_fn: R,
) -> HashMap<K, Vec<F>>
where
    K: Eq + std::hash::Hash + Send + 'static,
    V: Send + 'static,
    M: Fn(V) -> (K, F) + Send + Copy + 'static,
    F: Send + 'static,
    R: Fn(F, F) -> F + Send + Copy + 'static,
{
    // TODO: 实现 map-reduce
}
```

### 8. 超时控制

```rust
use std::time::Duration;

pub struct TimeoutExecutor {
    thread_pool: Arc<ThreadPool>,
}

impl TimeoutExecutor {
    pub fn new(size: usize) -> Self {
        // TODO: 创建带超时的执行器
    }

    pub fn execute_with_timeout<F, R>(
        &self,
        f: F,
        timeout: Duration,
    ) -> Result<R, TimeoutError>
    where
        F: FnOnce() -> R + Send + 'static,
        R: Send + 'static,
    {
        // TODO: 执行任务，支持超时
    }
}

#[derive(Debug)]
pub enum TimeoutError {
    Timeout,
    ExecutionError,
}
```

### 9. 进度跟踪

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

pub struct ProgressTracker {
    total: AtomicUsize,
    completed: AtomicUsize,
}

impl ProgressTracker {
    pub fn new(total: usize) -> Self {
        // TODO: 创建进度跟踪器
    }

    pub fn increment(&self) {
        // TODO: 原子地增加已完成计数
    }

    pub fn get_progress(&self) -> f64 {
        // TODO: 计算进度百分比
    }

    pub fn is_complete(&self) -> bool {
        // TODO: 检查是否完成
    }
}
```

### 10. 任务依赖

```rust
pub struct TaskGraph {
    tasks: Vec<Task>,
    dependencies: HashMap<usize, Vec<usize>>,
}

struct Task {
    id: usize,
    func: Box<dyn FnOnce() + Send>,
    completed: Arc<AtomicBool>,
}

impl TaskGraph {
    pub fn new() -> Self {
        // TODO: 创建任务图
    }

    pub fn add_task<F>(&mut self, f: F) -> usize
    where
        F: FnOnce() + Send + 'static,
    {
        // TODO: 添加任务，返回任务 ID
    }

    pub fn add_dependency(&mut self, task: usize, depends_on: usize) {
        // TODO: 添加任务依赖
    }

    pub fn execute(&self, pool: &ThreadPool) {
        // TODO: 按依赖顺序执行任务
    }
}
```

## 高级功能

### 11. 工作窃取

```rust
pub struct WorkStealingPool {
    workers: Vec<Worker>,
    global_queue: Arc<Mutex<VecDeque<Job>>>,
}

impl WorkStealingPool {
    pub fn new(size: usize) -> Self {
        // TODO: 创建工作窃取线程池
        // 每个线程有自己的本地队列
        // 空闲时从其他线程窃取任务
    }
}
```

### 12. 批处理

```rust
pub struct BatchExecutor {
    thread_pool: Arc<ThreadPool>,
    batch_size: usize,
}

impl BatchExecutor {
    pub fn new(pool: Arc<ThreadPool>, batch_size: usize) -> Self {
        // TODO: 创建批处理执行器
    }

    pub fn execute_batch<F, T, R>(&self, items: Vec<T>, f: F) -> Vec<R>
    where
        F: Fn(T) -> R + Send + Copy + 'static,
        T: Send + 'static,
        R: Send + 'static,
    {
        // TODO: 分批执行任务
    }
}
```

### 13. 流水线

```rust
pub struct Pipeline<T> {
    stages: Vec<Box<dyn Stage<T> + Send>>,
}

trait Stage<T>: Send {
    fn process(&self, input: T) -> T;
}

impl<T> Pipeline<T>
where
    T: Send + 'static,
{
    pub fn new() -> Self {
        // TODO: 创建流水线
    }

    pub fn add_stage<S>(mut self, stage: S) -> Self
    where
        S: Stage<T> + 'static,
    {
        // TODO: 添加处理阶段
    }

    pub fn execute(&self, input: T) -> T {
        // TODO: 按顺序执行所有阶段
    }
}
```

### 14. 并行文件处理

```rust
pub fn parallel_file_processor(paths: Vec<PathBuf>) -> Vec<FileResult> {
    // TODO: 并行处理多个文件
    // 支持读取、处理、写入
}

struct FileResult {
    path: PathBuf,
    content: Option<String>,
    error: Option<io::Error>,
}
```

### 15. 并发缓存

```rust
use std::sync::RwLock;
use std::collections::HashMap;

pub struct AsyncCache<K, V>
where
    K: Eq + std::hash::Hash,
{
    data: RwLock<HashMap<K, V>>,
    thread_pool: Arc<ThreadPool>,
}

impl<K, V> AsyncCache<K, V>
where
    K: Eq + std::hash::Hash + Send + Sync + 'static,
    V: Clone + Send + 'static,
{
    pub fn new(pool: Arc<ThreadPool>) -> Self {
        // TODO: 创建异步缓存
    }

    pub fn get_or_compute<F>(&self, key: K, f: F) -> V
    where
        K: Clone + 'static,
        F: FnOnce() -> V + Send + 'static,
    {
        // TODO: 如果 key 不存在，在线程池中计算
    }
}
```

## 测试要求

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_thread_pool_basic() {
        let pool = ThreadPool::new(4);
        let result = Arc::new(Mutex::new(0));

        for _ in 0..10 {
            let result_clone = Arc::clone(&result);
            pool.execute(move || {
                *result_clone.lock().unwrap() += 1;
            });
        }

        // TODO: 等待并验证结果
    }

    #[test]
    fn test_parallel_map() {
        let items = vec![1, 2, 3, 4, 5];
        let results = ParallelIterator::new(items).map(|x| x * 2);
        assert_eq!(results, vec![2, 4, 6, 8, 10]);
    }

    // TODO: 添加更多测试
}
```

## 性能考虑

1. **线程数选择**: 通常设置为 CPU 核心数
2. **任务粒度**: 任务不要太小，避免线程调度开销
3. **避免数据竞争**: 使用适当的同步原语
4. **减少锁竞争**: 使用无锁数据结构或减少临界区
5. **工作窃取**: 平衡负载，避免线程空闲

## 学习要点

通过这个综合练习，你将掌握：

- 线程池的实现
- Channel 消息传递
- Mutex 和 Arc 的使用
- 并行迭代器模式
- Map-Reduce 模式
- 超时和取消
- 任务依赖管理
- 工作窃取算法

## 完成标准

- [ ] 所有单元测试通过
- [ ] 所有集成测试通过
- [ ] 代码通过 clippy 检查
- [ ] 正确处理线程同步
- [ ] 避免数据竞争
- [ ] 代码格式化符合 rustfmt 标准
