# 自检清单

完成本模块学习后，使用此清单检查你的掌握情况。

## Iterator trait 基础

- [ ] 理解什么是迭代器
- [ ] 知道 Iterator trait 的核心方法（next()）
- [ ] 理解关联类型 Item
- [ ] 能实现基本的 Iterator trait
- [ ] 理解迭代器的生命周期
- [ ] 知道如何从迭代器获取值

## 消费者适配器

- [ ] 理解什么是消费者适配器
- [ ] 能使用 `collect()` 收集结果
- [ ] 能使用 `sum()` 计算总和
- [ ] 能使用 `product()` 计算乘积
- [ ] 能使用 `min()` 和 `max()` 找最值
- [ ] 能使用 `find()` 查找元素
- [ ] 能使用 `any()` 和 `all()` 检查条件
- [ ] 能使用 `fold()` 和 `reduce()` 累积计算
- [ ] 能使用 `count()` 计数
- [ ] 能使用 `last()` 和 `nth()` 获取元素
- [ ] 理解消费者适配器会消耗迭代器

## 迭代器适配器

- [ ] 理解什么是迭代器适配器
- [ ] 知道迭代器适配器是惰性的
- [ ] 能使用 `map()` 转换元素
- [ ] 能使用 `filter()` 和 `filter_map()` 过滤元素
- [ ] 能使用 `enumerate()` 添加索引
- [ ] 能使用 `zip()` 组合迭代器
- [ ] 能使用 `chain()` 连接迭代器
- [ ] 能使用 `take()`、`skip()` 获取/跳过元素
- [ ] 能使用 `take_while()`、`skip_while()` 条件获取/跳过
- [ ] 能使用 `flatten()` 和 `flat_map()` 扁平化
- [ ] 能使用 `rev()` 反转迭代器
- [ ] 能使用 `cloned()` 和 `copied()` 复制引用
- [ ] 理解迭代器适配器返回新迭代器

## 自定义迭代器

- [ ] 能定义实现 Iterator trait 的结构体
- [ ] 能正确实现 `type Item`
- [ ] 能正确实现 `next()` 方法
- [ ] 理解 `next()` 的返回值（`Option<Item>`）
- [ ] 能创建状态化的迭代器（如计数器）
- [ ] 能创建无限迭代器
- [ ] 知道如何为自定义迭代器实现其他方法

## 迭代器类型

- [ ] 理解 `iter()` 的作用（迭代不可变引用 `&T`）
- [ ] 理解 `iter_mut()` 的作用（迭代可变引用 `&mut T`）
- [ ] 理解 `into_iter()` 的作用（获取所有权 `T`）
- [ ] 能根据需要选择正确的迭代类型
- [ ] 理解三种迭代器的区别和使用场景

## 性能考虑

- [ ] 理解零成本抽象
- [ ] 理解迭代器与 for 循环性能相同
- [ ] 理解迭代器的惰性求值优势
- [ ] 能选择合适的操作以避免不必要的计算
- [ ] 理解 `copied()` vs `cloned()` 的性能差异
- [ ] 知道如何优化迭代器链

## 代码实践

- [ ] 完成了所有代码示例的学习
- [ ] 能够理解示例中的迭代器使用
- [ ] 能够修改示例代码进行实验
- [ ] 能独立实现简单的迭代器
- [ ] 能熟练使用各种迭代器方法
- [ ] 能链式调用多个迭代器方法

## 练习完成

- [ ] 练习 1：Iterator trait 基础
- [ ] 练习 2：消费者适配器 - sum 和 product
- [ ] 练习 3：迭代器适配器 - map 和 filter
- [ ] 练习 4：enumerate 和 zip
- [ ] 练习 5：fold 和 reduce
- [ ] 练习 6：flat_map 和 flatten
- [ ] 练习 7：take, skip, take_while, skip_while
- [ ] 练习 8：cloned 和 copied
- [ ] 练习 9：复杂迭代器链
- [ ] 练习 10：自定义迭代器 - 斐波那契数列
- [ ] 综合练习：数据管道处理系统

## 测试验证

- [ ] 所有单元测试通过
- [ ] 理解测试失败的原因
- [ ] 能编写迭代器的测试
- [ ] 能测试自定义迭代器的行为
- [ ] 能测试迭代器链的正确性

## 代码质量

- [ ] 代码符合 Rust 风格规范
- [ ] 迭代器命名清晰有意义
- [ ] 代码有适当的注释
- [ ] 使用 `cargo clippy` 检查
- [ ] 能选择最合适的迭代器方法

## 设计原则

- [ ] 理解何时使用迭代器而非 for 循环
- [ ] 能设计合理的迭代器链
- [ ] 能理解并选择合适的迭代器类型
- [ ] 能设计高效的迭代器操作
- [ ] 理解迭代器与函数式编程的关系

## 常见陷阱理解

- [ ] 知道 `.map(|x| x)` 应该用 `.copied()` 或 `.cloned()`
- [ ] 理解迭代器的借用规则
- [ ] 知道迭代器适配器的顺序
- [ ] 理解迭代器的性能影响
- [ ] 知道如何避免多次迭代同一个集合

## 高级特性

- [ ] 理解 Iterator 的其他方法（try_fold, scan 等）
- [ ] 理解 `ExactSizeIterator` trait
- [ ] 理解 `DoubleEndedIterator` trait
- [ ] 理解 `FusedIterator` trait
- [ ] 能实现这些高级 trait

## 迭代器模式

- [ ] 能使用迭代器实现 map-reduce 模式
- [ ] 能使用迭代器实现 filter-map 模式
- [ ] 能使用迭代器实现窗口滑动
- [ ] 能使用迭代器实现分组操作
- [ ] 能使用迭代器实现树遍历

## 性能优化

- [ ] 理解何时使用 `collect()`
- [ ] 理解何时使用惰性迭代器
- [ ] 能避免不必要的中间分配
- [ ] 能选择正确的迭代器类型（iter vs into_iter）
- [ ] 理解迭代器的内存布局

## 自我评估

请为以下方面打分（1-5 分）：

- **Iterator 理解**：掌握 Iterator trait 和相关概念
  - 评分：___/5

- **迭代器方法**：熟练使用各种迭代器方法
  - 评分：___/5

- **性能理解**：理解迭代器的性能特性
  - 评分：___/5

- **自定义迭代器**：能实现自定义迭代器
  - 评分：___/5

- **综合应用**：能设计高效的数据处理流程
  - 评分：___/5

**总分**：___/25

## 下一步建议

- **总分 < 15**：建议重新学习本模块内容，重点理解迭代器适配器和性能
- **总分 15-20**：建议加强自定义迭代器和高级模式的练习
- **总分 > 20**：恭喜！可以进入下一个模块学习了

**特别提醒**：
- 迭代器是 Rust 中强大的数据处理工具
- 掌握迭代器能写出更简洁、高效的代码
- 迭代器链是 Rust 函数式编程的核心
- 请确保完全掌握这些概念后再继续

## 进阶挑战

完成基础要求后，可以尝试：

- [ ] 实现自定义迭代器适配器
- [ ] 学习更多标准库迭代器方法
- [ ] 学习并行迭代器（rayon crate）
- [ ] 学习流式迭代器（stream crate）
- [ ] 学习惰性求值的更高级应用

---

**完成日期**：________________

**备注**（遇到的问题、心得体会等）：
<br>
<br>
<br>
