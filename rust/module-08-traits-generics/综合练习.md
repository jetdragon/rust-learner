# 综合练习：事件处理系统

## 项目描述

创建一个事件处理系统，演示 Trait、泛型和生命周期的综合应用。

## 项目结构

```
综合练习/
├── src/
│   ├── lib.rs           # 主库文件
│   ├── event.rs         # 事件定义
│   ├── handler.rs       # 处理器 Trait
│   ├── dispatcher.rs    # 事件分发器
│   └── middleware.rs    # 中间件
└── tests/
    └── integration.rs   # 集成测试
```

## 核心需求

### 1. 事件 Trait

```rust
pub trait Event {
    type Id;

    fn id(&self) -> Self::Id;
    fn name(&self) -> &str;
    fn timestamp(&self) -> u64;
    fn payload(&self) -> &str;
}
```

### 2. 具体事件类型

```rust
pub struct ClickEvent {
    event_id: String,
    ts: u64,
    x: i32,
    y: i32,
}

pub struct KeyEvent {
    event_id: String,
    ts: u64,
    key: char,
}

pub struct MessageEvent {
    event_id: String,
    ts: u64,
    content: String,
}

// TODO: 为每种事件实现 Event trait
```

### 3. 事件处理器 Trait

```rust
pub trait Handler<E: Event> {
    fn handle(&self, event: &E) -> Result<(), String>;

    fn can_handle(&self, event: &E) -> bool {
        true
    }
}
```

### 4. 泛型分发器

```rust
pub struct Dispatcher<E: Event> {
    handlers: Vec<Box<dyn Handler<E>>>,
}

impl<E: Event> Dispatcher<E> {
    pub fn new() -> Self {
        // TODO: 创建新的分发器
    }

    pub fn register<H: Handler<E> + 'static>(&mut self, handler: H) {
        // TODO: 注册处理器
    }

    pub fn dispatch(&self, event: &E) -> Result<(), String> {
        // TODO: 分发事件到所有能处理的处理器
    }

    pub fn dispatch_all(&self, events: &[E]) -> Result<(), String> {
        // TODO: 批量分发
    }
}
```

### 5. 日志中间件

```rust
pub struct LoggingMiddleware<H> {
    inner: H,
}

impl<H, E> Handler<E> for LoggingMiddleware<H>
where
    H: Handler<E>,
    E: Event,
{
    fn handle(&self, event: &E) -> Result<(), String> {
        println!("Handling event: {}", event.name());
        let result = self.inner.handle(event);
        match &result {
            Ok(()) => println!("Event handled successfully"),
            Err(e) => println!("Event handling failed: {}", e),
        }
        result
    }
}
```

### 6. 过滤中间件

```rust
pub struct FilterMiddleware<H, F>
where
    F: Fn(&E) -> bool,
{
    inner: H,
    predicate: F,
}

// TODO: 实现 Handler trait for FilterMiddleware
```

### 7. 事件存储

```rust
pub struct EventStore<'a, E: Event> {
    events: Vec<&'a E>,
}

impl<'a, E: Event> EventStore<'a, E> {
    pub fn new() -> Self {
        // TODO: 创建新的存储
    }

    pub fn store(&mut self, event: &'a E) {
        // TODO: 存储事件
    }

    pub fn find_by_id(&self, id: &E::Id) -> Option<&E> {
        // TODO: 查找事件
    }

    pub fn filter<F>(&self, predicate: F) -> Vec<&E>
    where
        F: Fn(&E) -> bool,
    {
        // TODO: 过滤事件
    }
}
```

### 8. 事件聚合

```rust
pub struct EventAggregator<E: Event> {
    buffer: Vec<E>,
    capacity: usize,
}

impl<E: Event> EventAggregator<E> {
    pub fn new(capacity: usize) -> Self {
        // TODO: 创建聚合器
    }

    pub fn push(&mut self, event: E) -> bool {
        // TODO: 添加事件，返回是否已满
    }

    pub fn flush(&mut self) -> Vec<E> {
        // TODO: 清空并返回所有事件
    }

    pub fn is_full(&self) -> bool {
        // TODO: 检查是否已满
    }
}
```

### 9. 优先级队列

```rust
use std::cmp::Reverse;

pub struct PriorityQueue<T: Ord> {
    inner: BinaryHeap<Reverse<T>>,
}

impl<T: Ord> PriorityQueue<T> {
    pub fn new() -> Self {
        // TODO: 创建优先级队列
    }

    pub fn push(&mut self, item: T) {
        // TODO: 添加元素
    }

    pub fn pop(&mut self) -> Option<T> {
        // TODO: 弹出最小元素
    }

    pub fn peek(&self) -> Option<&T> {
        // TODO: 查看最小元素
    }
}
```

### 10. 事件序列化

```rust
pub trait Serializable {
    fn serialize(&self) -> String;
    fn deserialize(s: &str) -> Result<Self, String>
    where
        Self: Sized;
}

// TODO: 为各种事件实现 Serializable
```

## 高级功能

### 11. 异步处理器 (使用 Fn trait)

```rust
pub struct AsyncHandler<F, E>
where
    F: Fn(&E) -> Result<(), String>,
{
    func: F,
}

impl<F, E> Handler<E> for AsyncHandler<F, E>
where
    E: Event,
    F: Fn(&E) -> Result<(), String>,
{
    // TODO: 实现 Handler trait
}
```

### 12. 处理器链

```rust
pub struct HandlerChain<E: Event> {
    handlers: Vec<Box<dyn Handler<E>>>,
    stop_on_error: bool,
}

impl<E: Event> HandlerChain<E> {
    pub fn new(stop_on_error: bool) -> Self {
        // TODO: 创建处理器链
    }

    pub fn add(&mut self, handler: Box<dyn Handler<E>>) {
        // TODO: 添加处理器
    }
}

// TODO: 为 HandlerChain 实现 Handler trait
```

### 13. 事件总线

```rust
pub struct EventBus<E: Event + Clone> {
    subscribers: Vec<Box<dyn Fn(&E) + Send + Sync>>,
    _phantom: PhantomData<E>,
}

impl<E: Event + Clone> EventBus<E> {
    pub fn new() -> Self {
        // TODO: 创建事件总线
    }

    pub fn subscribe<F>(&mut self, callback: F)
    where
        F: Fn(&E) + Send + Sync + 'static,
    {
        // TODO: 订阅事件
    }

    pub fn publish(&self, event: &E) {
        // TODO: 发布事件
    }
}
```

### 14. 类型擦除的事件

```rust
pub trait AnyEvent {
    fn as_any(&self) -> &dyn std::any::Any;
    fn name(&self) -> &str;
}

impl<E: Event> AnyEvent for E {
    fn as_any(&self) -> &dyn std::any::Any {
        self
    }

    fn name(&self) -> &str {
        Event::name(self)
    }
}

pub struct EventDispatcher {
    handlers: HashMap<
        String,
        Vec<Box<dyn Fn(&dyn AnyEvent) -> Result<(), String>>>,
    >,
}

// TODO: 实现类型擦除的分发器
```

### 15. 生命周期验证

```rust
pub struct EventValidator<'a, 'b, E: Event>
where
    'a: 'b,
{
    rules: Vec<Box<dyn Fn(&'b E) -> bool + 'a>>,
}

impl<'a, 'b, E: Event> EventValidator<'a, 'b, E>
where
    'a: 'b,
{
    pub fn new() -> Self {
        // TODO: 创建验证器
    }

    pub fn add_rule<F>(&mut self, rule: F)
    where
        F: Fn(&'b E) -> bool + 'a,
    {
        // TODO: 添加验证规则
    }

    pub fn validate(&self, event: &'b E) -> bool {
        // TODO: 验证事件
    }
}
```

## 测试要求

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_event_creation() {
        let click = ClickEvent::new("click-1", 12345, 100, 200);
        assert_eq!(click.id(), "click-1");
        assert_eq!(click.name(), "click");
    }

    #[test]
    fn test_dispatcher() {
        let mut dispatcher = Dispatcher::<ClickEvent>::new();

        dispatcher.register(ClickHandler);
        dispatcher.register(LoggingMiddleware::new(ClickHandler));

        let event = ClickEvent::new("click-1", 12345, 100, 200);
        assert!(dispatcher.dispatch(&event).is_ok());
    }

    #[test]
    fn test_event_store() {
        let event1 = ClickEvent::new("click-1", 12345, 100, 200);
        let event2 = ClickEvent::new("click-2", 12346, 150, 250);

        let mut store = EventStore::new();
        store.store(&event1);
        store.store(&event2);

        assert_eq!(store.events.len(), 2);
    }

    #[test]
    fn test_aggregator() {
        let mut aggregator = EventAggregator::<ClickEvent>::new(3);

        assert!(!aggregator.is_full());
        aggregator.push(ClickEvent::new("click-1", 12345, 100, 200));
        aggregator.push(ClickEvent::new("click-2", 12346, 150, 250));
        aggregator.push(ClickEvent::new("click-3", 12347, 200, 300));

        assert!(aggregator.is_full());
        assert_eq!(aggregator.flush().len(), 3);
    }

    #[test]
    fn test_priority_queue() {
        let mut pq = PriorityQueue::new();
        pq.push(5);
        pq.push(3);
        pq.push(7);

        assert_eq!(pq.pop(), Some(3));
        assert_eq!(pq.pop(), Some(5));
        assert_eq!(pq.pop(), Some(7));
    }
}
```

## 性能考虑

1. **避免不必要的克隆**: 使用引用和生命周期
2. **合理使用 Box<dyn Trait>**: 仅在需要时使用
3. **内联小函数**: 使用 `#[inline]`
4. **预分配容量**: `Vec::with_capacity()`

## 学习要点

通过这个综合练习，你将掌握：

- Trait 定义和实现
- 泛型结构体和函数
- 复杂的生命周期标注
- Trait 对象和动态分发
- 关联类型
- 运算符重载
- Fn 系列 Trait
- 高级 Trait Bound
- 类型擦除技术

## 完成标准

- [ ] 所有单元测试通过
- [ ] 所有集成测试通过
- [ ] 代码通过 clippy 检查
- [ ] 使用泛型避免重复代码
- [ ] 合理使用 Trait Bound
- [ ] 代码格式化符合 rustfmt 标准
