# 08-生命周期与高级类型 - 自检清单

## 生命周期基础

- [ ] 理解生命周期的概念
- [ ] 知道为什么需要生命周期
- [ ] 能够阅读生命周期注解
- [ ] 能够编写简单的生命周期标注

## 生命周期语法

- [ ] 理解 `&'a T` 语法
- [ ] 理解 `&'a mut T` 语法
- [ ] 理解 `<'a>` 参数声明
- [ ] 理解 `'static` 生命周期

## 生命周期省略规则

- [ ] 理解第一条规则：每个引用参数有自己的生命周期
- [ ] 理解第二条规则：单个输入生命周期赋给所有输出
- [ ] 理解第三条规则：方法的 self 生命周期
- [ ] 能够预测编译器何时能省略生命周期

## 函数中的生命周期

- [ ] 能够为函数标注生命周期
- [ ] 理解多个生命周期参数
- [ ] 理解生命周期之间的关系
- [ ] 能够解决生命周期编译错误

## 结构体中的生命周期

- [ ] 能够为结构体添加生命周期
- [ ] 理解为什么存储引用需要生命周期
- [ ] 能够为结构体方法正确标注生命周期
- [ ] 理解多个生命周期参数的结构体

## 生命周期子类型

- [ ] 理解生命周期子类型关系
- [ ] 理解 `'b: 'a` 约束
- [ ] 能够使用 where 子句指定生命周期关系
- [ ] 理解协变和逆变

## 生命周期边界

- [ ] 理解 `T: 'a` 约束
- [ ] 理解类型必须比生命周期更长
- [ ] 能够使用生命周期边界
- [ ] 理解生命周期与 Trait 结合

## 泛型与生命周期

- [ ] 能够同时使用泛型和生命周期
- [ ] 理解 `<'a, T: 'a>` 约束
- [ ] 能够编写泛型结构体并带生命周期
- [ ] 理解复杂的生命周期场景

## 方法中的生命周期

- [ ] 理解方法的 self 生命周期
- [ ] 能够省略不必要的生命周期标注
- [ ] 理解为什么方法通常不需要显式标注
- [ ] 理解返回 self 引用的方法

## 静态生命周期

- [ ] 理解 `'static` 的含义
- [ ] 知道何时使用 `'static`
- [ ] 知道字符串字面量的生命周期
- [ ] 理解 `'static` 不是必须的

## 高级类型

### 类型别名

- [ ] 理解类型别名的作用
- [ ] 能够定义类型别名
- [ ] 理解类型别名不是新类型
- [ ] 能够在函数签名中使用类型别名

### Never 类型

- [ ] 理解 `!` 类型的含义
- [ ] 知道哪些函数返回 `!`
- [ ] 理解 `panic!` 和 `loop` 的类型
- [ ] 理解发散函数

### DST (动态大小类型)

- [ ] 理解 DST 的概念
- [ ] 知道 `str` 是 DST
- [ ] 知道 `[T]` 是 DST
- [ ] 理解为什么 DST 需要通过引用使用

### Sized Trait

- [ ] 理解 Sized trait
- [ ] 知道泛型默认有 `T: Sized` 约束
- [ ] 理解 `?Sized` 约束
- [ ] 能够处理动态大小类型

## 实践能力

- [ ] 能够解决常见生命周期错误
- [ ] 能够设计零拷贝 API
- [ ] 能够避免不必要的克隆
- [ ] 能够使用 Cow 优化借用/拥有
- [ ] 能够阅读和编写复杂的生命周期代码

## 常见模式

- [ ] 解析字符串返回引用
- [ ] 结构体持有引用
- [ ] 迭代器模式
- [ ] 构建器模式
- [ ] 链表结构

## 调试技巧

- [ ] 能够理解生命周期错误信息
- [ ] 能够定位生命周期问题
- [ ] 知道何时使用 `'static`
- [ ] 知道何时重构以简化生命周期

## 性能考虑

- [ ] 理解生命周期不增加运行时开销
- [ ] 理解零拷贝解析的优势
- [ ] 知道如何避免克隆
- [ ] 理解 Cow 的使用场景

## 测试

通过以下测试验证理解：

```rust
// 1. 基础生命周期
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

// 2. 结构体生命周期
struct Context<'a> {
    data: &'a str,
}

// 3. 多个生命周期
fn compare<'a, 'b>(x: &'a str, y: &'b str) -> bool {
    x == y
}

// 4. 生命周期边界
struct Ref<'a, T: 'a> {
    value: &'a T,
}

// 5. 生命周期子类型
fn choose<'a, 'b>(x: &'a str, y: &'b str) -> &'a str
where
    'b: 'a,
{
    x
}

// 6. 类型别名
type StrRef<'a> = &'a str;
```

## 自测问题

1. 为什么需要生命周期？
2. 三条生命周期省略规则是什么？
3. `'static` 生命周期的含义是什么？
4. 如何决定使用 `&T` 还是 `&'a T`？
5. 结构体何时需要生命周期标注？
6. 什么是生命周期子类型？
7. `T: 'a` 约束是什么意思？
8. 类型别名和 newtype 有什么区别？
9. Never 类型 `!` 有什么用途？
10. 什么是 DST？
11. 如何避免不必要的克隆？
12. Cow 何时使用？
13. 为什么生命周期是编译时概念？
14. 如何处理复杂的生命周期错误？
15. 什么是零拷贝解析？
