# 自检清单

完成本模块学习后，使用此清单检查你的掌握情况。

## 智能指针基础

- [ ] 理解什么是智能指针
- [ ] 知道智能指针和普通引用的区别
- [ ] 理解智能指针拥有数据而非借用
- [ ] 知道智能指针提供额外的元数据

## Box<T>

- [ ] 理解 Box 的用途（堆分配）
- [ ] 能使用 Box::new() 创建堆分配对象
- [ ] 理解 Box 的自动解引用
- [ ] 知道何时需要使用 Box
  - [ ] 大数据不适合栈上
  - [ ] 递归类型
  - [ ] Trait Objects

- [ ] 能显式解引用（*boxed_value）
- [ ] 理解 Box 的内存布局

## Rc<T> (引用计数)

- [ ] 理解 Rc 的多所有权模式
- [ ] 能使用 Rc::new() 创建共享数据
- [ ] 能使用 Rc::clone() 增加引用计数
- [ ] 能使用 Rc::strong_count() 检查引用计数
- [ ] 理解 Rc 只能在单线程使用
- [ ] 知道 Rc 不会深度克隆数据
- [ ] 能使用 Rc 实现图结构

## Arc<T> (原子引用计数)

- [ ] 理解 Arc 是 Rc 的线程安全版本
- [ ] 知道 Arc vs Rc 的区别
  - [ ] 线程安全 vs 单线程
  - [ ] 性能差异（原子操作）
  - [ ] 使用场景

- [ ] 能使用 Arc::new() 创建线程安全共享数据
- [ ] 能使用 Arc::clone() 在多个线程间共享
- [ ] 能使用 Arc 与线程结合
- [ ] 理解 Arc 的性能开销

## Cell<T>

- [ ] 理解什么是内部可变性（Interior Mutability）
- [ ] 知道 Cell 的使用场景
- [ ] 能使用 Cell::new() 创建 Cell
- [ ] 能使用 cell.set() 修改值
- [ ] 能使用 cell.get() 读取值
- [ ] 理解 Cell 只适用于实现了 Copy 的类型
- [ ] 知道 Cell 没有借用检查

## RefCell<T>

- [ ] 理解 RefCell 的运行时借用检查
- [ ] 知道 RefCell 与 Cell 的区别
  - [ ] RefCell 适用于任意类型
  - [ ] RefCell 提供借用检查
  - [ ] 运行时 panic vs 编译时错误

- [ ] 能使用 RefCell::new() 创建 RefCell
- [ ] 能使用 refcell.borrow() 获取不可变借用
- [ ] 能使用 refcell.borrow_mut() 获取可变借用
- [ ] 理解 RefCell 的借用规则
  - [ ] 同一时间只能有一个可变借用
  - [ ] 或者可以有多个不可变借用
  - [ ] 违反规则会 panic

- [ ] 理解 RefCell 的性能影响

## Weak<T>

- [ ] 理解 Weak 引用的概念
- [ ] 知道 Weak 不增加引用计数
- [ ] 能使用 Weak::new() 创建弱引用
- [ ] 能使用 weak.upgrade() 升级为 Rc
- [ ] 理解 Weak 的返回类型（Option<Rc<T>>）
- [ ] 能识别循环引用问题
- [ ] 能使用 Weak 解决循环引用
- [ ] 理解 Weak 的使用场景

## Trait Objects

- [ ] 理解什么是 Trait Object
- [ ] 知道 dyn Trait 的含义
- [ ] 能使用 Box<dyn Trait> 存储 Trait Object
- [ ] 理解动态分发 vs 静态分发
- [ ] 知道 Trait Object 的限制
  - [ ] 不能有泛型参数
  - [ ] 不能返回 Self 类型
  - [ ] 必须是对象安全的

## 智能指针选择

- [ ] 能根据场景选择合适的智能指针
  - [ ] 单所有权：Box
  - [ ] 多所有权单线程：Rc
  - [ ] 多所有权多线程：Arc
  - [ ] 内部可变性 Copy：Cell
  - [ ] 内部可变性非 Copy：RefCell

- [ ] 理解所有权与引用的区别
- [ ] 能合理设计所有权结构
- [ ] 能避免不必要的克隆

## 代码实践

- [ ] 完成了所有代码示例的学习
- [ ] 能够理解示例中的智能指针使用
- [ ] 能够修改示例代码进行实验
- [ ] 能独立使用 Box 创建堆分配对象
- [ ] 能独立使用 Rc 实现多所有权
- [ ] 能独立使用 Arc 实现线程安全共享
- [ ] 能独立使用 Cell/RefCell 实现内部可变性

## 练习完成

- [ ] 练习 1：Box 基础使用
- [ ] 练习 2：递归类型使用 Box
- [ ] 练习 3：Rc 多所有权
- [ ] 练习 4：Arc 并发共享
- [ ] 练习 5：Cell 内部可变性
- [ ] 练习 6：RefCell 运行时借用检查
- [ ] 练习 7：Weak 避免循环引用
- [ ] 练习 8：Trait Objects 与 Box
- [ ] 练习 9：综合应用 - 文件系统
- [ ] 练习 10：综合应用 - 图结构
- [ ] 综合练习：内存池管理器

## 测试验证

- [ ] 所有单元测试通过
- [ ] 理解测试失败的原因
- [ ] 能编写智能指针的测试
- [ ] 能检测循环引用
- [ ] 能测试线程安全性

## 代码质量

- [ ] 代码符合 Rust 风格规范
- [ ] 避免过度使用 Rc/RefCell
- [ ] 能检测循环引用
- [ ] 代码有适当的注释
- [ ] 使用 `cargo clippy` 检查

## 设计原则

- [ ] 理解何时使用智能指针而非普通引用
- [ ] 能设计避免循环引用的数据结构
- [ ] 理解性能考虑
  - [ ] Box 的堆分配开销
  - [ ] Rc/Arc 的引用计数开销
  - [ ] Cell/RefCell 的运行时检查开销

- [ ] 理解零成本抽象
- [ ] 能在简单和灵活之间选择

## 常见陷阱理解

- [ ] 知道循环引用的症状
- [ ] 知道 RefCell 违反借用规则的后果
- [ ] 理解 Rc 不是深度克隆
- [ ] 知道 Cell 只适用于 Copy 类型
- [ ] 理解 Arc 的性能开销
- [ ] 知道如何选择合适的智能指针

## 内存管理

- [ ] 理解堆 vs 栈分配
- [ ] 理解引用计数的原理
- [ ] 理解内存泄漏的原因
- [ ] 能使用工具检测内存问题
- [ ] 能设计避免内存泄漏的结构

## 并发编程

- [ ] 理解线程安全的概念
- [ ] 知道何时使用 Arc
- [ ] 能正确使用 Arc + Mutex 模式
- [ ] 理解数据竞争
- [ ] 能设计线程安全的数据结构

## 自我评估

请为以下方面打分（1-5 分）：

- **Box 理解**：掌握堆分配和递归类型
  - 评分：___/5

- **Rc/Arc 理解**：掌握多所有权和线程安全
  - 评分：___/5

- **Cell/RefCell 理解**：掌握内部可变性
  - 评分：___/5

- **Weak 理解**：能避免循环引用
  - 评分：___/5

- **综合应用**：能设计合理的所有权结构
  - 评分：___/5

**总分**：___/25

## 下一步建议

- **总分 < 15**：建议重新学习本模块内容，重点理解引用计数和内部可变性
- **总分 15-20**：建议加强并发编程和循环引用处理的练习
- **总分 > 20**：恭喜！可以进入下一个模块学习了

**特别提醒**：
- 智能指针是 Rust 高级特性的基础
- 理解所有权系统对掌握 Rust 至关重要
- 请确保完全掌握这些概念后再继续

## 进阶挑战

完成基础要求后，可以尝试：

- [ ] 实现自定义智能指针
- [ ] 研究更多智能指针类型（Cow、RcWeak 等）
- [ ] 学习 Pin 和 Unpin
- [ ] 实现复杂的并发数据结构
- [ ] 学习异步运行时中的智能指针使用

---

**完成日期**：________________

**备注**（遇到的问题、心得体会等）：
<br>
<br>
<br>
