# 综合练习：内存池管理器

## 项目简介

本综合练习需要你运用智能指针的知识，实现一个支持多种智能指针的内存池管理器系统。该项目将综合使用 Box、Rc、Arc、Cell、RefCell 和 Weak。

## 项目需求

### 功能描述

创建一个内存池管理器，支持：
1. 大对象的堆分配（Box）
2. 共享对象的多所有权（Rc）
3. 线程安全的对象共享（Arc）
4. 内部可变性（Cell 和 RefCell）
5. 避免循环引用（Weak）

### 核心数据结构

#### 1. 内存池项

```rust
enum PoolItem {
    LargeObject(Box<Vec<u8>>),
    SharedObject(Rc<RefCell<Vec<u8>>>),
    ThreadSafeObject(Arc<Mutex<Vec<u8>>>),
    Null,
}
```

#### 2. 内存池引用

```rust
struct PoolRef {
    id: u32,
    item: PoolItem,
    size: usize,
    created_at: std::time::Instant,
}
```

#### 3. 内存池统计

```rust
struct PoolStats {
    total_allocations: Cell<u64>,
    total_deallocations: Cell<u64>,
    active_objects: Cell<u64>,
    total_memory: Cell<usize>,
}
```

#### 4. 内存池

```rust
struct MemoryPool {
    items: RefCell<HashMap<u32, Rc<RefCell<PoolRef>>>>,
    next_id: Cell<u32>,
    stats: PoolStats,
}
```

### 必须实现的功能

#### MemoryPool 方法

1. `new() -> Self`
   - 创建新的内存池

2. `allocate_large(&self, size: usize) -> Result<Rc<RefCell<PoolRef>>, String>`
   - 分配大对象（使用 Box）
   - 返回对象的引用

3. `allocate_shared(&self, data: Vec<u8>) -> Result<Rc<RefCell<PoolRef>>, String>`
   - 分配共享对象（使用 Rc<RefCell>）
   - 返回对象的引用

4. `allocate_threadsafe(&self, data: Vec<u8>) -> Result<Rc<RefCell<PoolRef>>, String>`
   - 分配线程安全对象（使用 Arc<Mutex>）
   - 返回对象的引用

5. `deallocate(&self, id: u32) -> Result<(), String>`
   - 释放指定 ID 的对象
   - 更新统计信息

6. `get_ref(&self, id: u32) -> Option<Rc<RefCell<PoolRef>>>`
   - 获取对象的引用

7. `clone_ref(&self, id: u32) -> Result<Rc<RefCell<PoolRef>>, String>`
   - 克隆现有引用（用于 Rc/Arc）

8. `get_stats(&self) -> PoolStatsSnapshot`
   - 获取内存池快照

#### PoolRef 方法

9. `read_data(&self) -> Option<Vec<u8>>`
   - 读取对象数据（处理不同类型的 PoolItem）

10. `write_data(&self, data: Vec<u8>) -> Result<(), String>`
    - 写入对象数据（使用内部可变性）

#### PoolStats 方法

11. `increment_allocations(&self)`
    - 增加分配计数

12. `increment_deallocations(&self)`
    - 增加释放计数

13. `add_memory(&self, size: usize)`
    - 添加内存计数

14. `remove_memory(&self, size: usize)`
    - 移除内存计数

15. `snapshot(&self) -> PoolStatsSnapshot`
    - 创建统计快照

### 使用示例

```rust
use module_11_smart_pointers::memory_pool::*;

fn main() {
    // 创建内存池
    let pool = MemoryPool::new();

    // 分配大对象
    let large_data = vec
![1, 2, 3, 4, 5];
    let large_ref = pool.allocate_large(1024).unwrap();
    large_ref.borrow().write_data(large_data).unwrap();

    // 分配共享对象
    let shared_data = vec
![10, 20, 30];
    let shared_ref = pool.allocate_shared(shared_data.clone()).unwrap();

    // 克隆共享引用
    let shared_clone = pool.clone_ref(shared_ref.borrow().id).unwrap();

    // 分配线程安全对象
    let safe_data = vec
![100, 200, 300];
    let safe_ref = pool.allocate_threadsafe(safe_data).unwrap();

    // 并发访问
    use std::thread;

    let ref1 = safe_ref.clone();
    let ref2 = safe_ref.clone();

    let handle1 = thread::spawn(move || {
        ref1.borrow().write_data(vec
![1, 2, 3]).unwrap();
    });

    let handle2 = thread::spawn(move || {
        let data = ref2.borrow().read_data().unwrap();
        println!("线程2读取: {:?}", data);
    });

    handle1.join().unwrap();
    handle2.join().unwrap();

    // 释放对象
    pool.deallocate(large_ref.borrow().id).unwrap();

    // 查看统计
    let stats = pool.get_stats();
    println!("总分配: {}", stats.total_allocations);
    println!("总释放: {}", stats.total_deallocations);
    println!("活动对象: {}", stats.active_objects);
    println!("总内存: {} bytes", stats.total_memory);
}
```

## 验收标准

### 功能要求

- [ ] 支持三种对象类型（Large、Shared、ThreadSafe）
- [ ] Box 正确处理堆分配
- [ ] Rc 正确处理多所有权
- [ ] Arc 正确处理线程安全
- [ ] Cell/RefCell 提供内部可变性
- [ ] 正确统计内存使用情况
- [ ] 错误处理完善

### 代码质量

- [ ] 所有单元测试通过
- [ ] 代码通过 `cargo clippy` 检查
- [ ] 代码格式化 `cargo fmt`
- [ ] 有适当的文档注释
- [ ] 没有内存泄漏

### 并发安全

- [ ] Arc+Mutex 实现正确
- [ ] 多线程访问安全
- [ ] 没有数据竞争

### 性能考虑

- [ ] 避免不必要的克隆
- [ ] 合理使用智能指针
- [ ] 内存使用高效

## 实现步骤

1. **创建文件结构**：
   ```bash
   mkdir -p src/memory_pool
   touch src/memory_pool/mod.rs
   touch src/memory_pool/types.rs
   touch src/memory_pool/pool.rs
   touch src/memory_pool/stats.rs
   ```

2. **实现类型定义**：
   - 定义 PoolItem 枚举
   - 定义 PoolRef 结构体
   - 定义 PoolStats 结构体
   - 定义 PoolStatsSnapshot 结构体

3. **实现统计模块**：
   - 实现 PoolStats 方法
   - 使用 Cell 提供内部可变性

4. **实现池管理**：
   - 实现 MemoryPool 核心逻辑
   - 使用 RefCell 提供内部可变性
   - 使用 HashMap 管理对象

5. **实现不同类型的分配**：
   - allocate_large: Box
   - allocate_shared: Rc<RefCell>
   - allocate_threadsafe: Arc<Mutex>

6. **实现读写操作**：
   - read_data: 处理不同 PoolItem 类型
   - write_data: 使用内部可变性

7. **编写测试**：
   - 单元测试
   - 并发测试
   - 内存泄漏测试

8. **运行验证**：
   ```bash
   cargo test -p module-11-smart-pointers
   cargo clippy -p module-11-smart-pointers
   cargo fmt -p module-11-smart-pointers
   ```

## 测试用例

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_box_allocation() {
        let pool = MemoryPool::new();
        let ref_obj = pool.allocate_large(100).unwrap();
        assert!(ref_obj.borrow().read_data().is_some());
    }

    #[test]
    fn test_rc_shared() {
        let pool = MemoryPool::new();
        let data = vec
![1, 2, 3];
        let ref1 = pool.allocate_shared(data.clone()).unwrap();
        let ref2 = pool.clone_ref(ref1.borrow().id).unwrap();

        // 验证两个引用指向同一份数据
        let data1 = ref1.borrow().read_data().unwrap();
        let data2 = ref2.borrow().read_data().unwrap();
        assert_eq!(data1, data2);
    }

    #[test]
    fn test_arc_threadsafe() {
        let pool = MemoryPool::new();
        let data = vec
![10, 20, 30];
        let ref_obj = pool.allocate_threadsafe(data).unwrap();

        use std::thread;
        let handle = thread::spawn({
            let ref_obj = ref_obj.clone();
            move || {
                ref_obj.borrow().read_data().unwrap();
            }
        });

        handle.join().unwrap();
    }

    #[test]
    fn test_deallocation() {
        let pool = MemoryPool::new();
        let ref_obj = pool.allocate_large(100).unwrap();
        let id = ref_obj.borrow().id;

        pool.deallocate(id).unwrap();
        assert!(pool.get_ref(id).is_none());
    }

    #[test]
    fn test_stats_tracking() {
        let pool = MemoryPool::new();
        let _ref1 = pool.allocate_large(100).unwrap();
        let _ref2 = pool.allocate_shared(vec
![1, 2, 3]).unwrap();

        let stats = pool.get_stats();
        assert_eq!(stats.total_allocations, 2);
        assert_eq!(stats.active_objects, 2);
    }

    #[test]
    fn test_interior_mutability() {
        let pool = MemoryPool::new();
        let ref_obj = pool.allocate_shared(vec
![1, 2, 3]).unwrap();

        let initial_data = ref_obj.borrow().read_data().unwrap();
        assert_eq!(initial_data, vec
![1, 2, 3]);

        ref_obj.borrow().write_data(vec
![4, 5, 6]).unwrap();
        let new_data = ref_obj.borrow().read_data().unwrap();
        assert_eq!(new_data, vec
![4, 5, 6]);
    }
}
```

## 扩展挑战（可选）

完成基础要求后，可以尝试以下扩展：

1. **对象池复用**：
   - 释放的对象不立即删除
   - 重用已释放的对象减少分配开销

2. **内存限制**：
   - 设置最大内存限制
   - 超出限制时返回错误

3. **LRU 缓存**：
   - 最近最少使用的对象自动释放
   - 限制活跃对象数量

4. **性能监控**：
   - 记录分配/释放时间
   - 计算平均分配时间
   - 统计不同类型对象的使用情况

5. **引用计数跟踪**：
   - 显示每个对象的引用计数
   - 检测异常高的引用计数

## 提示

<details>
<summary>PoolItem 读取提示</summary>

```rust
impl PoolRef {
    pub fn read_data(&self) -> Option<Vec<u8>> {
        match &self.item {
            PoolItem::LargeObject(boxed) => Some(boxed.as_ref().clone()),
            PoolItem::SharedObject(rc_ref) => Some(rc_ref.borrow().clone()),
            PoolItem::ThreadSafeObject(arc_mutex) => {
                Some(arc_mutex.lock().unwrap().clone())
            }
            PoolItem::Null => None,
        }
    }
}
```

</details>

<details>
<summary>PoolItem 写入提示</summary>

```rust
impl PoolRef {
    pub fn write_data(&self, data: Vec<u8>) -> Result<(), String> {
        match &self.item {
            PoolItem::LargeObject(_) => Err("不可变".to_string()),
            PoolItem::SharedObject(rc_ref) => {
                *rc_ref.borrow_mut() = data;
                Ok(())
            }
            PoolItem::ThreadSafeObject(arc_mutex) => {
                *arc_mutex.lock().unwrap() = data;
                Ok(())
            }
            PoolItem::Null => Err("空对象".to_string()),
        }
    }
}
```

</details>

<details>
<summary>Weak 引用提示</summary>

```rust
struct Node {
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}

impl Node {
    fn get_parent(&self) -> Option<Rc<Node>> {
        self.parent.borrow().upgrade()
    }
}
```

</details>

## 学习目标

通过本项目，你将：

1. **掌握智能指针选择**：
   - 何时使用 Box
   - 何时使用 Rc
   - 何时使用 Arc

2. **理解内部可变性**：
   - Cell 的使用场景
   - RefCell 的运行时借用检查

3. **避免内存泄漏**：
   - 识别循环引用
   - 使用 Weak 解决循环引用

4. **线程安全编程**：
   - Arc + Mutex 模式
   - 跨线程共享数据

5. **设计内存管理**：
   - 合理组织内存结构
   - 实现高效的分配和释放

## 参考实现

完成项目后，可以查看 `solutions/memory_pool.rs` 中的参考实现。
